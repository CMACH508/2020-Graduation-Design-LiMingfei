clear 
clc 
coordinates = [
0.5254202315299458 0.30607312799508546
0.06075461523140302 0.44895403213938667
0.7025219088544769 0.45225978341785533
0.41222006598240524 0.8939137603876508
0.1635222012661981 0.4420324100926971
0.49015014037796834 0.06595714720135926
0.7050207734102788 0.9931136395749547
0.3265347025176928 0.30081513143490735
0.6607381276176673 0.5097396535854799
0.18964735849590464 0.13592582630550687
0.43558088488082514 0.24611150925724923
0.6396300852216221 0.7807164856778911
0.7827309624146682 0.9323969866523415
0.18878080891072346 0.5680149809027484
0.28464235102892543 0.6539469930473318
0.022465602767837045 0.786185237800776
0.41376665925751976 0.2925892882877238
0.44273233250217736 0.979384890006989
0.6411870321031059 0.4894190289821273
0.9432054042760042 0.021145718765415378
0.6247916452688935 0.7720359490782929
0.4257290317169382 0.14466627027920032
0.08167068302626912 0.3027706146515332
0.1268660198047652 0.024377496557618117
0.18058870456180753 0.05230633096538939
0.8375752274617471 0.042063064065182565
0.581400215725743 0.11047543694130524
0.5552149760185542 0.9960187533949936
0.1764466250992729 0.06415010455948156
0.3052116166978873 0.7430224898734326
0.5366948452642355 0.8469509849403176
0.29256705241379866 0.4248794145420608
0.12021755051218697 0.6573304090542745
0.2760778703447171 0.44406018795252755
0.03675593883617456 0.16701434644100188
0.3494124608696342 0.7575131351991471
0.5128828236809359 0.040985867638201334
0.9613278102477935 0.6746690746822843
0.02616490432086427 0.29854408957667455
0.8021247906042845 0.8470356455038806
0.1621989222906849 0.06846949228996535
0.9767617709719433 0.9680059234252766
0.9831380868089367 0.531825845438959
0.44531881661643025 0.12488163060512159
0.40858014872619797 0.5803095921969518
0.6656688241371812 0.8000352144183176
0.7548092811782264 0.5130633219204329
0.045302949909277856 0.2736415282855187 0.590758234083014 0.4385633049815336 0.9570955007474033 0.11083452954434603 0.4804778585459162 0.3783437375828428 0.5775919997125794 0.2794337757414783 0.15087468534554527 0.0473407500422689 0.038434818600945664 0.3221759421724204 0.3419282925734263 0.4704456974763658 0.05924510760694268 0.8075530546500538 0.1343156569083367 0.41081894147762743 0.4176405405351754 0.05013246783026315 0.6073737408522306 0.3855484336824635 0.9753580185982496 0.28516601138574804 0.21710822737842517 0.02499186619144278 0.2902803617255898 0.7343747163367552 0.5765776583566149 0.5984940404528778 0.8775990977535971 0.6266764434571114 0.9495316134852739 0.5441363383000467 0.6633806675033478 0.4899626824581933 0.5982162600722949 0.7701525856340612 0.34376937958996756 0.26597656400124314 0.32298451935559147 0.4734958232510792 0.24813074060442586 0.3692628092514667 0.13683818463776332 0.8371868732831033 0.45644116188576567 0.08920859942008164 0.07525363272264252 0.009945816626766635 0.3695556974923294 0.17343252827172184 0.2955296015076534 0.6339786777670028 0.13765605281284377 0.5088397778257736 0.30385299148418254 0.5891265456162008 0.5630023633351162 0.4250817589307415 0.0456467209932967 0.6605936194616373 0.03259517273045398 0.548732089116177 0.1392654993226521 0.9976169289330006 0.848555807602856 0.8854687792346718 0.2850842932277685 0.40332155103109735 0.0009915437094397683 0.8350659100421404 0.6100433943245642 0.3337644777042118 0.8716133594862955 0.8597798926527813 0.006785138351039888 0.22731473849062056 0.06967231704142451 0.25874968203755944 0.8150084975400731 0.09983636659666062 0.09657746964991654 0.3079277928291677 0.3073094950739874 0.5911018324779138 0.4416279332015396 0.7793223502597946 0.5139312362188297 0.3825612229190214 0.7193921601567195 0.7264764685617677 0.09186614222516232 0.5068774944095162 0.18086720619802188 0.3656424361459415 0.25664150332538904 0.3685032100282314 0.6513757358692935 0.6115275242799313 0.8593575714154873 0.5868387479979176 0.21931405519162184 0.5879290660967446
];

amount = size(coordinates,1); 

%compute_dist_matric
coor_x_tmp1 = coordinates(:,1) * ones(1,amount);
coor_x_tmp2 = coor_x_tmp1';
coor_y_tmp1 = coordinates(:,2) * ones(1,amount);
coor_y_tmp2 = coor_y_tmp1';
d = sqrt((coor_x_tmp1 - coor_x_tmp2).^2 + (coor_y_tmp1 - coor_y_tmp2).^2);


n = size(d,1);
% 决策变量
x = binvar(n,n,'full');
u = sdpvar(1,n);
% 目标
z = sum(sum(d.*x));
% 约束添加
C = [];
for j = 1:n
    s = sum(x(:,j))-x(j,j);
    C = [C,   s  == 1];
end
for i = 1:n
    s = sum(x(i,:)) - x(i,i);
    C = [C, s  == 1];
end
for i = 2:n
    for j = 2:n
        if i~=j
            C = [C,u(i)-u(j) + n*x(i,j)<=n-1];
        end
    end
end
% 参数设置
ops = sdpsettings('solver','gurobi','verbose',1);
% 求解
result  = optimize(C,z);
if result.problem== 0
    
    value(z)
else
    yalmiperror(result.problem)
end
b=value(x);
k = 1;
path = [k];
for i=1:size(b,1)
     %寻找当前行k中的1所在的位置
     for j=1:size(b,2)
        if(b(k,j) >= 1)
            k = j;
            path = [path, k];
            break;
        end
     end
end
 
path




a = 0.99; %温度衰减参数
t0 = 97; tf = 5; t = t0; %初始温度 终值
Markov_length = 10000; %Markov链长度
%产生初始解
sol_new = 1:n;
%sol代表当前路线 new代表每次产生的新解 current代表当前解 best代表冷却过程中的最优解
E_current = inf;
E_best = inf;
%E代表目标函数的值 也就是距离和 new代表新解的遍历距离 best最优解
sol_current = sol_new;
sol_best = sol_new;
p = 1; %初始化P
iter=1;
while t >= tf %当温度大于停止温度时
    for r = 1:Markov_length %Markov链长度
        %产生随机扰动
        if(rand < 0.5) %随机决定而交换还是三交换
            %二交换
            ind1 = 0; ind2 = 0;
            while(ind1 == ind2)
                ind1 = ceil(rand.*n); %朝正无穷大四舍五入
                ind2 = ceil(rand.*n);
            end
            tmp1 = sol_new(ind1);
            sol_new(ind1) = sol_new(ind2);
            sol_new(ind2) = tmp1;
        else
            %三交换
            ind1 = 0; ind2 = 0; ind3 = 0;
            while(ind1 == ind2) || (ind1 == ind3) || (ind2 == ind3) || (abs(ind1 - ind2) == 1) %三变换两个点之间没有路径
                ind1 = ceil(rand.*n);
                ind2 = ceil(rand.*n);
                ind3 = ceil(rand.*n);
            end
                %tmp1 = ind1;tmp2 = ind2;tmp3 = ind3;
                %排序ind1<ind2<ind3
                ind = [ind1 ind2 ind3];
                ind_sort = sort(ind);
                ind1 = ind_sort(1);
                ind2 = ind_sort(2);
                ind3 = ind_sort(3);
                %进行交换
                
                tmplist1 = sol_new((ind1 + 1):(ind2 - 1));
                sol_new((ind1 + 1):(ind1 + ind3 - ind2 + 1)) = sol_new((ind2) : (ind3));
                sol_new((ind1 + ind3 - ind2 + 2):ind3) = tmplist1;
        end
        %检查是否满足约束条件
        %计算目标函数函数值（类比于内能）
        E_new = 0;
        for i = 1 : (n - 1)
            E_new = E_new + d(sol_new(i),sol_new(i+1));
        end
        %加上最后一个到第一个的距离
        E_new = E_new + d(sol_new(n),sol_new(1)); 
        if E_new < E_current %当出现更优解时 更新为更优解的路线和目标函数值
            E_current = E_new;
            sol_current = sol_new;
            if E_new < E_best
                pre_E_best = E_best;
                E_best = E_new;
                sol_best = sol_new;
                iter=iter+1;
            end
        else
        %一定范围内接受非优解
            if rand < exp(-(E_new - E_current)./t)
                E_current = E_new;
                sol_current = sol_new;
            else
                sol_new = sol_current;
            end
        end
    end
    pre_t = t;
    t = t.* a;%更新控制参数t为原来的a倍

end
disp('最优解为:')
for i = 1 : amount
fprintf(' %d', sol_best(i));
end
E_best
ratio=(E_best-value(z))/value(z)
